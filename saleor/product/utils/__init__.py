from typing import TYPE_CHECKING, List, Union
from urllib.parse import urlencode

from django.conf import settings
from django.db import transaction

from ...core.taxes import TaxedMoney, zero_taxed_money
from ..tasks import update_products_minimal_variant_prices_task, update_product_minimal_variant_price_task

if TYPE_CHECKING:
    # flake8: noqa
    from datetime import date, datetime

    from django.db.models.query import QuerySet

    from ..models import Product, ProductVariant, Category


def calculate_revenue_for_variant(
    variant: "ProductVariant", start_date: Union["date", "datetime"]
) -> TaxedMoney:
    """Calculate total revenue generated by a product variant."""
    revenue = zero_taxed_money()
    for order_line in variant.order_lines.all():
        if order_line.order.created >= start_date:
            net = order_line.unit_price_net * order_line.quantity
            gross = order_line.unit_price_gross * order_line.quantity
            revenue += TaxedMoney(net, gross)
    return revenue


@transaction.atomic
def delete_categories(categories_ids: List[str]):
    """Delete categories and perform all necessary actions.

    Set products of deleted categories as unpublished, delete categories
    and update products minimal variant prices.
    """
    from ..models import Product, Category

    categories = Category.objects.select_for_update().filter(pk__in=categories_ids)
    categories.prefetch_related("products")

    products = Product.objects.none()
    for category in categories:
        products = products | collect_categories_tree_products(category)

    products.update(is_published=False, publication_date=None)
    product_ids = list(products.values_list("id", flat=True))
    categories.delete()
    update_products_minimal_variant_prices_task.delay(product_ids=product_ids)


def collect_categories_tree_products(category: "Category") -> "QuerySet[Product]":
    """Collect products from all levels in category tree."""
    products = category.products.all()
    descendants = category.get_descendants()
    for descendant in descendants:
        products = products | descendant.products.all()
    return products


@transaction.atomic
def delete_variants(variants_id: List[str]):
    """Delete variants and set default variant accordingly.

    """
    from ..models import ProductVariant

    variants = ProductVariant.objects.select_for_update().filter(pk__in=variants_id)
    variants.prefetch_related("product")

    for variant in variants:
        product = variant.product
        if product.variants.count() == 1:
            base_variant = ProductVariant(
                product=product,
                sku=variant.sku,
                price_amount=variant.price_amount,
                requires_shipping=variant.requires_shipping,
                currency=variant.currency,
                charge_taxes=variant.charge_taxes,
                track_inventory=variant.track_inventory)
            variant.delete()
            base_variant.save()

            product.base_variant = base_variant
            product.save()
            update_product_minimal_variant_price_task.delay(product.pk)
        else:
            variant.delete()
